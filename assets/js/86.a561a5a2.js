(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{333:function(e,a,t){"use strict";t.r(a);var n=t(18),o=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"biome-text-pipelines-learn-allennlp-default-callback-trainer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#biome-text-pipelines-learn-allennlp-default-callback-trainer"}},[e._v("#")]),e._v(" biome.text.pipelines.learn.allennlp.default_callback_trainer "),t("Badge",{attrs:{text:"Module"}})],1),e._v(" "),t("p",[e._v("This module includes the default biome callback trainer and some extra functions/classes for this purpose")]),e._v(" "),t("dl",[t("h2",{attrs:{id:"biome.text.pipelines.learn.allennlp.default_callback_trainer.DefaultCallbackTrainer"}},[e._v("DefaultCallbackTrainer "),t("Badge",{attrs:{text:"Class"}})],1),e._v(" "),t("dt",[t("div",{staticClass:"language-python extra-class"},[t("pre",{staticClass:"language-python"},[e._v("    "),t("code",[e._v("\n"),t("span",{staticClass:"token keyword"},[e._v("class")]),e._v(" "),t("span",{staticClass:"ident"},[e._v("DefaultCallbackTrainer")]),e._v(" ("),e._v("\n    "),t("span",[e._v("model: allennlp.models.model.Model")]),t("span",[e._v(",")]),e._v("\n    "),t("span",[e._v("training_data: Iterable[allennlp.data.instance.Instance]")]),t("span",[e._v(",")]),e._v("\n    "),t("span",[e._v("iterator: allennlp.data.iterators.data_iterator.DataIterator")]),t("span",[e._v(",")]),e._v("\n    "),t("span",[e._v("optimizer: torch.optim.optimizer.Optimizer")]),t("span",[e._v(",")]),e._v("\n    "),t("span",[e._v("num_epochs: int = 20")]),t("span",[e._v(",")]),e._v("\n    "),t("span",[e._v("shuffle: bool = True")]),t("span",[e._v(",")]),e._v("\n    "),t("span",[e._v("serialization_dir: Union[str, NoneType] = None")]),t("span",[e._v(",")]),e._v("\n    "),t("span",[e._v("cuda_device: Union[int, List] = -1")]),t("span",[e._v(",")]),e._v("\n    "),t("span",[e._v("callbacks: List[allennlp.training.callbacks.callback.Callback] = None")]),t("span",[e._v(",")]),e._v("\n"),t("span",[e._v(")")]),e._v("\n    ")])])])]),e._v(" "),t("dd",[t("div",{staticClass:"desc"},[t("p",[e._v("An callback trainer with some extra callbacks already configured")]),e._v(" "),t("p",[e._v("A trainer for doing supervised learning. It just takes a labeled dataset\nand a "),t("code",[e._v("DataIterator")]),e._v(", and uses the supplied "),t("code",[e._v("Optimizer")]),e._v(" to learn the weights\nfor your model over some fixed number of epochs. It uses callbacks to handle various\nthings ancillary to training, like tracking metrics, validation, early stopping,\nlogging to tensorboard, and so on.")]),e._v(" "),t("p",[e._v("It's easy to create your own callbacks; for example, if you wanted to get a Slack\nnotification when training finishes. For more complicated variations, you might have\nto create your own subclass, in which case make sure to fire off all the training events.")]),e._v(" "),t("h2",{attrs:{id:"parameters"}},[e._v("Parameters")]),e._v(" "),t("p",[e._v("model : "),t("code",[e._v("Model")]),e._v(", required.\nAn AllenNLP model to be optimized. Pytorch Modules can also be optimized if\ntheir "),t("code",[e._v("forward")]),e._v(' method returns a dictionary with a "loss" key, containing a\nscalar tensor representing the loss function to be optimized.')]),e._v(" "),t("pre",[t("code",[e._v("If you are training your model using GPUs, your model should already be\non the correct device. (If you use <code>Trainer.from\\_params</code> this will be\nhandled for you.)\n")])]),e._v(" "),t("dl",[t("dt",[t("strong",[t("code",[e._v("training_data")])]),e._v(" : "),t("code",[t("code",[e._v("Iterable\\[Instance]</code>, required")])])]),e._v(" "),t("dd",[e._v("The instances that you want to train your model on.")]),e._v(" "),t("dt",[t("strong",[t("code",[e._v("iterator")])]),e._v(" : "),t("code",[t("code",[e._v("DataIterator</code>, required")])])]),e._v(" "),t("dd",[e._v("The iterator for batching / epoch-ing the instances.")]),e._v(" "),t("dt",[e._v("optimizer : "),t("code",[e._v("torch.nn.Optimizer")]),e._v(", required.")]),e._v(" "),t("dt",[e._v("An instance of a Pytorch Optimizer, instantiated with the parameters of the")]),e._v(" "),t("dt",[e._v("model to be optimized.")]),e._v(" "),t("dt",[t("strong",[t("code",[e._v("num_epochs")])]),e._v(" : "),t("code",[e._v("int")]),e._v(", optional "),t("code",[e._v("(default=20)")])]),e._v(" "),t("dd",[e._v("Number of training epochs.")]),e._v(" "),t("dt",[t("strong",[t("code",[e._v("shuffle")])]),e._v(" : "),t("code",[e._v("bool")]),e._v(", optional "),t("code",[e._v("(default=True)")])]),e._v(" "),t("dd",[e._v("Whether to shuffle the instances each epoch.")]),e._v(" "),t("dt",[t("strong",[t("code",[e._v("serialization_dir")])]),e._v(" : "),t("code",[e._v("str")]),e._v(", optional "),t("code",[e._v("(default=None)")])]),e._v(" "),t("dd",[e._v("Path to directory for saving and loading model files. Models will not be saved if\nthis parameter is not passed.")]),e._v(" "),t("dt",[t("strong",[t("code",[e._v("cuda_device")])]),e._v(" : "),t("code",[e._v("Union[int, List[int]]")]),e._v(", optional "),t("code",[e._v("(default=-1)")])]),e._v(" "),t("dd",[e._v("An integer or list of integers specifying the CUDA device(s) to use. If -1, the CPU is used.")]),e._v(" "),t("dt",[t("strong",[t("code",[e._v("callbacks")])]),e._v(" : "),t("code",[e._v("List[Callback]")]),e._v(", optional "),t("code",[e._v("(default=None)")])]),e._v(" "),t("dd",[e._v("A list of callbacks that will be called based on training events.")])])]),e._v(" "),t("h3",[e._v("Ancestors")]),e._v(" "),t("ul",{staticClass:"hlist"},[t("li",[e._v("allennlp.training.callback_trainer.CallbackTrainer")]),e._v(" "),t("li",[e._v("allennlp.training.trainer_base.TrainerBase")]),e._v(" "),t("li",[e._v("allennlp.common.registrable.Registrable")]),e._v(" "),t("li",[e._v("allennlp.common.from_params.FromParams")])]),e._v(" "),t("dl",[t("h3",{attrs:{id:"biome.text.pipelines.learn.allennlp.default_callback_trainer.DefaultCallbackTrainer.from_params"}},[e._v("from_params "),t("Badge",{attrs:{text:"Static method"}})],1),e._v(" "),t("dt",[t("div",{staticClass:"language-python extra-class"},[t("pre",{staticClass:"language-python"},[t("code",[e._v("\n"),t("span",{staticClass:"token keyword"},[e._v("def")]),e._v(" "),t("span",{staticClass:"ident"},[e._v("from_params")]),e._v(" ("),e._v("\n   params: allennlp.common.params.Params,\n   serialization_dir: str,\n   recover: bool = False,\n   cache_directory: str = None,\n   cache_prefix: str = None,\n)  -> allennlp.training.callback_trainer.CallbackTrainer\n")]),e._v("\n        ")])])]),e._v(" "),t("dd",[t("div",{staticClass:"desc"},[t("p",[e._v("This is the automatic implementation of "),t("code",[e._v("from_params")]),e._v(". Any class that subclasses "),t("code",[e._v("FromParams")]),e._v("\n(or "),t("code",[e._v("Registrable")]),e._v(", which itself subclasses "),t("code",[e._v("FromParams")]),e._v(') gets this implementation for free.\nIf you want your class to be instantiated from params in the "obvious" way – pop off parameters\nand hand them to your constructor with the same names – this provides that functionality.')]),e._v(" "),t("p",[e._v("If you need more complex logic in your from "),t("code",[e._v("from_params")]),e._v(" method, you'll have to implement\nyour own method that overrides this one.")])])])])])])])}),[],!1,null,null,null);a.default=o.exports}}]);