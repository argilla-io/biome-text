(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{383:function(e,t,s){"use strict";s.r(t);var a=s(26),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"biome-text-modules-specs-defs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#biome-text-modules-specs-defs"}},[e._v("#")]),e._v(" biome.text.modules.specs.defs "),s("Badge",{attrs:{text:"Module"}})],1),e._v(" "),s("div"),e._v(" "),s("div"),e._v(" "),s("pre",{staticClass:"title"},[s("h2",{attrs:{id:"componentspec"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#componentspec"}},[e._v("#")]),e._v(" ComponentSpec "),s("Badge",{attrs:{text:"Class"}})],1),e._v("\n")]),e._v(" "),s("pre",{staticClass:"language-python"},[s("code",[e._v("\n"),s("span",{staticClass:"token keyword"},[e._v("class")]),e._v(" "),s("span",{staticClass:"ident"},[e._v("ComponentSpec")]),e._v(" (*args, **kwds)"),e._v("\n")]),e._v("\n")]),e._v(" "),s("p",[e._v("The layer spec component allows create Pytorch modules lazily,\nand instantiate them inside a context (Model or other component) dimension layer chain.")]),e._v(" "),s("p",[e._v("The layer spec wraps a component params and will generate an instance of type T once the input_dim is set.")]),e._v(" "),s("pre",{staticClass:"title"},[s("h3",{attrs:{id:"ancestors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ancestors"}},[e._v("#")]),e._v(" Ancestors")]),e._v("\n")]),e._v(" "),s("ul",{staticClass:"hlist"},[s("li",[e._v("typing.Generic")]),e._v(" "),s("li",[e._v("allennlp.common.from_params.FromParams")])]),e._v(" "),s("pre",{staticClass:"title"},[s("h3",{attrs:{id:"subclasses"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#subclasses"}},[e._v("#")]),e._v(" Subclasses")]),e._v("\n")]),e._v(" "),s("ul",{staticClass:"hlist"},[s("li",[s("a",{attrs:{title:"biome.text.modules.heads.classification.doc_classification.DocumentClassificationSpec",href:"../heads/classification/doc_classification.html#biome.text.modules.heads.classification.doc_classification.DocumentClassificationSpec"}},[e._v("DocumentClassificationSpec")])]),e._v(" "),s("li",[s("a",{attrs:{title:"biome.text.modules.heads.classification.record_classification.RecordClassificationSpec",href:"../heads/classification/record_classification.html#biome.text.modules.heads.classification.record_classification.RecordClassificationSpec"}},[e._v("RecordClassificationSpec")])]),e._v(" "),s("li",[s("a",{attrs:{title:"biome.text.modules.heads.classification.text_classification.TextClassificationSpec",href:"../heads/classification/text_classification.html#biome.text.modules.heads.classification.text_classification.TextClassificationSpec"}},[e._v("TextClassificationSpec")])]),e._v(" "),s("li",[s("a",{attrs:{title:"biome.text.modules.heads.language_modelling.LanguageModellingSpec",href:"../heads/language_modelling.html#biome.text.modules.heads.language_modelling.LanguageModellingSpec"}},[e._v("LanguageModellingSpec")])]),e._v(" "),s("li",[s("a",{attrs:{title:"biome.text.modules.heads.task_head.TaskHeadSpec",href:"../heads/task_head.html#biome.text.modules.heads.task_head.TaskHeadSpec"}},[e._v("TaskHeadSpec")])]),e._v(" "),s("li",[s("a",{attrs:{title:"biome.text.modules.heads.token_classification.TokenClassificationSpec",href:"../heads/token_classification.html#biome.text.modules.heads.token_classification.TokenClassificationSpec"}},[e._v("TokenClassificationSpec")])]),e._v(" "),s("li",[s("a",{attrs:{title:"biome.text.modules.specs.allennlp_specs.BiMpmMatchingSpec",href:"allennlp_specs.html#biome.text.modules.specs.allennlp_specs.BiMpmMatchingSpec"}},[e._v("BiMpmMatchingSpec")])]),e._v(" "),s("li",[s("a",{attrs:{title:"biome.text.modules.specs.allennlp_specs.FeedForwardSpec",href:"allennlp_specs.html#biome.text.modules.specs.allennlp_specs.FeedForwardSpec"}},[e._v("FeedForwardSpec")])]),e._v(" "),s("li",[s("a",{attrs:{title:"biome.text.modules.specs.allennlp_specs.Seq2SeqEncoderSpec",href:"allennlp_specs.html#biome.text.modules.specs.allennlp_specs.Seq2SeqEncoderSpec"}},[e._v("Seq2SeqEncoderSpec")])]),e._v(" "),s("li",[s("a",{attrs:{title:"biome.text.modules.specs.allennlp_specs.Seq2VecEncoderSpec",href:"allennlp_specs.html#biome.text.modules.specs.allennlp_specs.Seq2VecEncoderSpec"}},[e._v("Seq2VecEncoderSpec")])])]),e._v(" "),s("dl",[s("pre",{staticClass:"title"},[s("h3",{attrs:{id:"from-params"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#from-params"}},[e._v("#")]),e._v(" from_params "),s("Badge",{attrs:{text:"Static method"}})],1),e._v("\n")]),e._v(" "),s("dt",[s("div",{staticClass:"language-python extra-class"},[s("pre",{staticClass:"language-python"},[s("code",[e._v("\n"),s("span",{staticClass:"token keyword"},[e._v("def")]),e._v(" "),s("span",{staticClass:"ident"},[e._v("from_params")]),e._v(" ("),e._v("\n  params: allennlp.common.params.Params,\n  **extras,\n)  -> ~T\n")]),e._v("\n")])])]),e._v(" "),s("dd",[s("p",[e._v("This is the automatic implementation of "),s("code",[e._v("from_params")]),e._v(". Any class that subclasses\n"),s("code",[e._v("FromParams")]),e._v(" (or "),s("code",[e._v("Registrable")]),e._v(", which itself subclasses "),s("code",[e._v("FromParams")]),e._v(') gets this\nimplementation for free.\nIf you want your class to be instantiated from params in the\n"obvious" way – pop off parameters and hand them to your constructor with the same names –\nthis provides that functionality.')]),e._v(" "),s("p",[e._v("If you need more complex logic in your from "),s("code",[e._v("from_params")]),e._v(" method, you'll have to implement\nyour own method that overrides this one.")]),e._v(" "),s("p",[e._v("The "),s("code",[e._v("constructor_to_call")]),e._v(" and "),s("code",[e._v("constructor_to_inspect")]),e._v(" arguments deal with a bit of\nredirection that we do.\nWe allow you to register particular "),s("code",[e._v("@classmethods")]),e._v(" on a class as\nthe constructor to use for a registered name.\nThis lets you, e.g., have a single\n"),s("code",[e._v("Vocabulary")]),e._v(" class that can be constructed in two different ways, with different names\nregistered to each constructor.\nIn order to handle this, we need to know not just the class\nwe're trying to construct ("),s("code",[e._v("cls")]),e._v("), but also what method we should inspect to find its\narguments ("),s("code",[e._v("constructor_to_inspect")]),e._v("), and what method to call when we're done constructing\narguments ("),s("code",[e._v("constructor_to_call")]),e._v(").\nThese two methods are the same when you've used a\n"),s("code",[e._v("@classmethod")]),e._v(" as your constructor, but they are "),s("code",[e._v("different")]),e._v(" when you use the default\nconstructor (because you inspect "),s("code",[e._v("__init__")]),e._v(", but call "),s("code",[e._v("cls()")]),e._v(").")])])]),e._v(" "),s("pre",{staticClass:"title"},[s("h3",{attrs:{id:"instance-variables"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#instance-variables"}},[e._v("#")]),e._v(" Instance variables")]),e._v("\n")]),e._v(" "),s("dl",[s("dt",{attrs:{id:"biome.text.modules.specs.defs.ComponentSpec.config"}},[s("code",{staticClass:"name"},[e._v("var "),s("span",{staticClass:"ident"},[e._v("config")]),e._v(" : Dict[str, Any]")])]),e._v(" "),s("dd",[s("p",[e._v("Component read-only configuration")])])]),e._v(" "),s("dl",[s("pre",{staticClass:"title"},[s("h3",{attrs:{id:"input-dim"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#input-dim"}},[e._v("#")]),e._v(" input_dim "),s("Badge",{attrs:{text:"Method"}})],1),e._v("\n")]),e._v(" "),s("dt",[s("div",{staticClass:"language-python extra-class"},[s("pre",{staticClass:"language-python"},[s("code",[e._v("\n"),s("span",{staticClass:"token keyword"},[e._v("def")]),e._v(" "),s("span",{staticClass:"ident"},[e._v("input_dim")]),e._v(" ("),e._v("\n  self,\n  input_dim: int,\n)  -> "),s("a",{attrs:{title:"biome.text.modules.specs.defs.ComponentSpec",href:"#biome.text.modules.specs.defs.ComponentSpec"}},[e._v("ComponentSpec")]),e._v("\n")]),e._v("\n")])])]),e._v(" "),s("dd",[s("p",[e._v("Sets the input dimension attribute for this layer configuration")])]),e._v(" "),s("pre",{staticClass:"title"},[s("h3",{attrs:{id:"compile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compile"}},[e._v("#")]),e._v(" compile "),s("Badge",{attrs:{text:"Method"}})],1),e._v("\n")]),e._v(" "),s("dt",[s("div",{staticClass:"language-python extra-class"},[s("pre",{staticClass:"language-python"},[s("code",[e._v("\n"),s("span",{staticClass:"token keyword"},[e._v("def")]),e._v(" "),s("span",{staticClass:"ident"},[e._v("compile")]),e._v(" ("),e._v("\n  self,\n  **extras,\n)  -> ~T\n")]),e._v("\n")])])]),e._v(" "),s("dd",[s("p",[e._v("Using the wrapped configuration and the input dimension, generates a\ninstance of type T representing the layer configuration")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);